---
title: "Linear Regression with Simulated Genotypes"
author: "Jean Morrison"
date: "December 29, 2016"
output: pdf_document
bibliography: ci_bib.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This document is an accompanies the paper "Rank conditional coverage and confidence intervals in high dimensional problems." by Jean Morrison and Noah Simon. Here we walk through in detail the linear regression simulations in section 3.1 and reproduce the results shown in the paper. 
The paper is also accompanied by an `R` package `rcc` which can be found at [github.com/jean997/rcc](https://github.com/jean997/rcc). This package includes all the code needed to reproduce the results shown and we will make use of it throughout this document.

## Generating Genotypes

Genotypes were generated using MACS (@Chen2009a) which can be downloaded [here](https://github.com/gchen98/macs). 
MACS will generate SNP genotypes from a coalescent model. We generated five blocks of genotypes each 150kb long in 10,000 individuals (the "populaton"). For each block we set the mutation rate per 4$N_e$ generations to 0.001. Since the recombination rate can differ across the genome, we let the recombination rate per site per 4$N_e$ generations be different in each block --- we used value of 0.001, 0.01, 0.002, 0.004, and 0.001 which span the range of reasonable values for humans. Higher recombination rates lead to less LD per block. 

From the total population of 10,000, we chose a sample of size 100. We then pruned the SNPs in each block to include only those with a sample minor allele frequency greater than 0.05 and so that the pairwise sample correaltion between SNPs was less than 0.8. This last step prevents us from including SNPs that are in perfect LD. Finally, we retain the first 100 SNPs in each block. 

The `make.genos()` function in the `rcc` package replicates our procedure for generating genotypes. These genotypes are also in the built-in data set `population_genotypes` in the `rcc` package.
To use the `make.genos()` function you will need to install the MACS, and the `SNPRelate` and `GWASTools` packages from Bioconductor. The function takes two arguments --- the location you have downloaded MACS to (e.g. the directory containing the `macs` and `msformatter` executables) and a temporary directory which defaults to `./`.

## Running Simulations

In this simulation there are 500 genetic variants. We are trying to use the data from the sample of size 100 to estimate the observed effect in the population of size 10,000. We consider 4 combinations of effect sizes for the 500 variants:

1. All effects equal to 0.
1. 10 effects are equal to 2 and the rest are equal to 0.
1. 10 effects are drawn from a $N(0, 1)$ distribution and the rest are 0.
1. 490 effects are drawn from a $N(0, 0.25)$ distribution, 10 are drawn from a $N(2, 1)$ distribution, and the rest are zero. 

In the last three cases, the non-zero effects are distributed evenly among the five LD blocks. We will now walk through one simulation. Everything that follows is consolidated into the `run1_linreg_sim` function and if you only want to replicate the results in the paper you can jump to the code at the end.


In each of the four cases, parameter values are fixed over all simulations. Parameters were generated with the function `rcc:::create_linreg_params` and stored in the built-in data set `linreg_params` This is a list with four elements each of which is a 2 column table giving the index of non-zero SNPs and their effect sizes.

## Detailed Simulation walk through
Here we will walk through one simulation using the second parameter configuration. 

### Generating Phenotypes and Calculating Marginal Effects
The first step is to generate a phenotype vector for the whole population.

```{r}
set.seed(6198560)

data("population_genotypes", package="rcc")
n=100
p <- 500

data("linreg_params", package="rcc")
index <- linreg_params[[2]]$index
beta <- matrix(linreg_params[[2]]$effect, nrow=10)
#Create the phenotype
err <- rnorm(n=500)
y <- population_genotypes[, index] %*% beta + err
```

The function `many_lr` calculates the observed linear effect in the whole population for each SNP. This took about 4 minutes on a laptop.
```{r popeffects, cache=TRUE}
library(parallel)
effects.pop <- rcc:::many_lr(y, population_genotypes, parallel=TRUE)
names(effects.pop)
effects <- effects.pop$beta_hat
```
This gives us the effect sizes that we are trying to estimate. Note that we are interested in estimating the observed marginal linear effects in the population, not the parameters used to generate the data. This is important because correlation between SNPs means that even though most of the *conditional* effects used to create the data are zero, the marginal effects will all be non-zero.

The sample is the first 100 individuals in the `population_genotype` matrix. The next step is to try to estimate the population effects using just this sample. 

```{r sampleeffects, cache=TRUE}
estimates <-  rcc:::many_lr(y[1:100], population_genotypes[1:100, ])
j <- order(abs(estimates$beta_hat/estimates$se_hat), decreasing = TRUE)
rank <- match(1:500, j)
```

### Marginal Confidence Intervals


```{r, echo=FALSE}
library(ggplot2)
library(rcc)
```

To construct the standard marginal 90\% confidence intervals:
```{r marg}
ci.naive <- cbind(estimates$beta_hat- estimates$se_hat*qnorm(0.95), estimates$beta_hat + estimates$se_hat*qnorm(0.95))
#Overall average coverage
sum(ci.naive[,1] <= effects & effects <= ci.naive[,2])/500
```
As we have seen before, these intervals disproportionately fail to cover parameters associated with top ranked estimates. Here we show the marginal intervals for the top 100 parameters colored by whether or not the true parameter is covered. Points show the true population linear effects.
```{r plotnaive, echo=FALSE, out.width="0.5\\textwidth"}
rcc:::plot_cis(rank, ci.naive, effects, prop=0.2, plot.truth = TRUE)
```

### Bootstrap Confidence Intervals
Parametric bootstrap confidence intervals are constructed using the `par_bs_ci` function in the `rcc` package. This function is described in detail in the walkthrough of the example in Section 1.5 (here) so we will skip that here.

```{r parci, cache=TRUE}
ci.par <- par_bs_ci(estimates$beta_hat, se=estimates$se_hat,n.rep=1000, level=0.1)
sum(ci.par[,1] <= effects & effects <= ci.par[,2])/500
```

Here we show the intervals for the top 100 parameters colored by whether or not the true parameter is covered by the parametric boostrap interval. Points show the true population linear effects.
```{r plotpar, echo=FALSE, out.width="0.5\\textwidth"}
rcc:::plot_cis(rank, ci.par, effects, prop=0.2, plot.truth = TRUE) + ggtitle("Parametric Bootstrap Intervals")
```

For the non-parametric bootstrap we resample genotypes from the sample genotype matrix, recalculate estimates and use the difference between the original estimates and the bootstrap estimates as an estimate of the bias. This procedure is described in Algorithm 3 and implemented in the `lr_bs_nonpar` function in the `rcc` package. Here is the code for the bootstrapping step:


```{r nonpar, cache=TRUE}
X <- population_genotypes[1:100,]
y.sample <- y[1:100]
B <- replicate(n=1000, expr={
	S <- sample(1:n, size=n, replace=TRUE)
	y.new <- y.sample[S]
	X.new <- X[S, ]
	b <- rcc:::many_lr(y.new, X.new)
	#order by t-statistic
	t.stat <- b$beta_hat/b$se_hat
	t.stat[ b$beta_hat ==0 & b$se_hat==0] <- 0
	k <- order(abs(t.stat), decreasing=TRUE)
	s <- sign(t.stat[k])
	s[t.stat[k] ==0] <- 1
	s*(b$beta_hat[k] - estimates$beta_hat[k])
})
```

Next we calculate the quantiles of the bias for each rank
```{r}
qs <- apply(B, MARGIN=1, FUN=function(x){quantile(x, probs=c(0.05, 0.9))})
```
And pivot:
```{r}
ci.nonpar <- cbind(estimates$beta_hat[j]-qs[2,], estimates$beta_hat[j]-qs[1,])
#We are using absolute value so the pivot is different for negative estimates
which.neg <- which(estimates$beta_hat[j] < 0)
ci.nonpar[ which.neg , ] <- cbind(estimates$beta_hat[j][which.neg] + qs[1,which.neg],
	                              estimates$beta_hat[j][which.neg]+qs[2,which.neg])

#Put interval in the original order
ci.nonpar <- ci.nonpar[rank,]
sum(ci.nonpar[,1] <= effects & effects <= ci.nonpar[,2])/500
```

```{r plotnonpar, echo=FALSE, out.width="0.5\\textwidth"}
rcc:::plot_cis(rank, ci.nonpar, effects, prop=0.2, plot.truth = TRUE) + ggtitle("Non-Parametric Bootstrap Intervals")
```

Testing new code:

```{r}
lr_func <- function(data){
  y <- data[,1]
  X <- data[, -1]
  ests <- rcc:::many_lr(y, X)
  df <- data.frame("estimate"=ests$beta_hat, "statistic"=ests$beta_hat/ests$se_hat)
  return(df)
}
data <- cbind(y[1:100], population_genotypes[1:100,])
ci.nonpar <- nonpar_bs_ci(data, analysis.func = lr_func, parallel=TRUE)$ci
rcc:::plot_cis(rank, ci.nonpar, effects, prop=0.2, plot.truth = TRUE) + ggtitle("Non-Parametric Bootstrap Intervals")
```

## Selection Adjusted confidence intervals

We calculate the selection adjusted intervals of  @Weinstein2013  and @Reid2014 conditional on selecting the top 10\% of parameters. This is very similar to the code shown for the exampl in Section 1.5.

### Intervals of @Weinstein2013

```{r wfb}
t <- estimates$beta_hat/estimates$se_hat
#effective threshold
ct <- abs(t)[j][51]
wfb <- lapply(t, FUN=function(x){
	if(abs(x) < ct) return(c(NA, NA))
	ci <- try(rcc:::Shortest.CI(x, ct=ct, alpha=0.1), silent=TRUE)
  if(class(ci) == "try-error") return(c(NA, NA))
	return(ci)
})
ci.wfb <- matrix(unlist(wfb), byrow=TRUE, nrow=p)
ci.wfb[,1] <- ci.wfb[,1]*estimates$se_hat
ci.wfb[,2] <- ci.wfb[,2]*estimates$se_hat
sum(ci.wfb[,1] <= effects & effects <= ci.wfb[,2], na.rm=TRUE)/50
```
```{r plotwfb, echo=FALSE, out.width="0.5\\textwidth"}

rcc:::plot_cis(rank, ci.wfb, effects.pop$beta_hat, prop=0.2, plot.truth = TRUE) + 
  ggtitle("Weinstein, Fithian, and Benjamini Intervals")
```


### Intervals of @Reid2014

```{r rtt, cache=TRUE}
library(selectiveInference)
M <- manyMeans(y=t, k=50, alpha=0.1, sigma=1)
ci.rtt <- matrix(nrow=p, ncol=2)
ci.rtt[M$selected.set, ] <- M$ci
ci.rtt[,1] <- ci.rtt[,1]*estimates$se_hat
ci.rtt[,2] <- ci.rtt[,2]*estimates$se_hat
sum(ci.rtt[,1] <= effects & effects <= ci.rtt[,2], na.rm=TRUE)/50
```

```{r plotrtt, echo=FALSE, out.width="0.5\\textwidth"}

rcc:::plot_cis(rank, ci.rtt, effects.pop$beta_hat, prop=0.2, plot.truth = TRUE) + 
  ggtitle("Reid, Taylor, and Tibshirani Intervals")
```

## Empirical Bayes Intervals
Here we calculate the `ashr` credible intervals of @Stephens2016. In this problem, these have under-coverage.

```{r ashr, message=FALSE}
library(ashr)
ash.res <- ash(betahat = estimates$beta_hat, sebetahat = estimates$se_hat, mixcompdist = "normal")
ci.ash <- ashci(ash.res, level=0.9, betaindex = 1:500, trace=FALSE)
sum(ci.ash[,1]<= effects & ci.ash[,2] >= effects)/500
```

```{r plotash, echo=FALSE, out.width="0.5\\textwidth"}
rcc:::plot_cis(rank, ci.ash, effects, prop=0.2, plot.truth=TRUE) + ggtitle("ashr Credible Intervals (Stephens 2016)")
```

## Replicate the results in the paper

The following loop will run all of the simulations. However, because each simulation takes several minutes, it is much better to run these in parallel if that is an option. In order to facilitate running the simulations in parallel, we include the function `run1_linreg` which runs only one simulation and writes the results to a file. We will the collect all of these results into a single object and make plots.
```{r, eval=FALSE}
set.seed(5989615)
all.seeds <- floor(runif(n=400, min=1000, max=1e7))

for(beta.type in c("none", "ten_equal", "ten_norm", "mixture")){
    for(i in 1:400){
      run1_linreg_sim(beta.type=beta.type, which.run=i, file.prefix="linreg", seed=all.seeds[i])
    }
}
```

Now we need to collect them all of the results:

```{r, eval=FALSE}
for(beta.type in c("none", "ten_equal", "ten_norm", "mixture")){
    COVERAGE <- array(dim=c(7, 500, 400))
    WIDTH <- array(dim=c(7, 500, 400))
    for(i in 1:400){
      z <- rcc:::getobj(paste0("linreg_", beta.type, "_n", i, ".RData"))
      COVERAGE[, , i] <- z$COVERAGE
      WIDTH[, , i] <- z$WIDTH
    }
    simnames <- z$simnames
    Z <- list("COVERAGE"=COVERAGE, "WIDTH"=WIDTH, "simnames"=simnames)
    save(Z, file=paste0("linreg_", beta.type, ".RData"))
}
```
The results generated by the code in this section are available for download [here](https://github.com/jean997/rcc/sim_results).
Here is the code for generating the plots in the paer. It should be run from the directory including the files `linreg_none.RData`, `linreg_ten_equal.RData`, `linreg_ten_norm.RData`, and `linreg_mixture.RData`. 

```{r, eval=FALSE}
library(tidyr)
setwd("sim_results/")
files <- c("linreg_none.RData", "linreg_ten_equal.RData", "linreg_ten_norm.RData", "linreg_mixture.RData")
titles <- c("No Genetic Effects", "Ten Large Effects", "Ten Small Dispersed Effects", "Combination of Large\nand Small Effects")
covplots <- list()
widthplots <- list()
for(i in 1:4){
  lp <- "none"
  results <- getobj(files[i])
  covplots[[i]] <- plot_coverage(results, proportion=0.2,
      cols=c("black",  "deeppink3",  "red", "gold4", "forestgreen", "purple"),
      simnames=c("naive",  "par",    "nonpar", "ash", "wfb", "selInf1"),
      ltys= c(2, 1, 3, 6, 4, 2), span=0.5, main=titles[i], y.range=c(-0.02, 1.02),
      legend.position = lp) + theme(plot.title=element_text(hjust=0.5))
  widthplots[[i]] <- plot_width(results, proportion=0.2,
      cols=c("black",  "deeppink3",  "red", "gold4", "forestgreen", "purple"),
      simnames=c("naive",  "par",    "nonpar", "ash", "wfb", "selInf1"),
      ltys= c(2, 1, 3, 6, 4, 2), span=0.5, main=titles[i],
      legend.position = lp)+ theme(plot.title=element_text(hjust=0.5))

}
legend <- rcc:::make_sim_legend(legend.names = c("Marginal", "Parametric\nBootstrap", 
                                                 "Non-Parametric\nBootstrap", "ashr", "WFB", "RTT"), 
            cols=c("black",  "deeppink3",  "red", "gold4", "forestgreen", "purple"),
            ltys= c(2, 1, 3, 6, 4, 2))

h1 <- grid.arrange(covplots[[1]], covplots[[2]], covplots[[3]], covplots[[4]], ncol=4)
h2 <- grid.arrange(widthplots[[1]], widthplots[[2]], widthplots[[3]], widthplots[[4]], ncol=4)
```
```{r, echo=FALSE, eval=FALSE}
ggsave(h1, file="~/Dropbox/rcc-temp/for_jcgs/img/lin_reg_cov.pdf", heigh=4, width=16, units="in", dpi=300)
ggsave(h2, file="~/Dropbox/rcc-temp/for_jcgs/img/lin_reg_width.pdf", heigh=4, width=16, units="in", dpi=300)
ggsave(legend$plot, file="~/Dropbox/rcc-temp/for_jcgs/img/lin_reg_legend.pdf", height=1, width=8, units="in", dpi=300)
```
## References
